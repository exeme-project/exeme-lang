import "std.cf"
import "std.io"

use cf::range

; MU stands for MeasurementUnit

Geometry: trait<io::Stringify>(MU: Int|UInt|Float) = {
	area: func(Self) -> MU, ; Not defining logic, so we must define parameters later
	toString: func(self: Self) -> String { ; Defining logic, so we must define parameters
		return self.area() as String
	}
}

; UFloat don't exist
Rectangle: struct<Geometry>(MU: UInt|Float) = {
	height, width: MU,
}

Square: struct<Geometry>(MU: UInt|Float) = {
	side: MU,
}

; Types are pre-defined, so only parameters have to be specified
Rectangle.area = func(self) {
	return self.height * self.width
}

Square.area = func(self) {
	return self.side ** 2
}

main: func() = {
	; Default int type is i32

	my_rectangle = Rectangle(i32) {
		height = 5,
		width = 10
	}

	my_square = Square(i32) {
		side = 5
	}

	my_shapes = [my_rectangle, my_square] ; Again, type inference

	for range(0, my_shapes.length) => shape {
		io::out(shape.area()) ; Requires the variable to infer from and implement 'io::Stringify'
    }
}
